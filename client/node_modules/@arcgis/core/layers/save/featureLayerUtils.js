/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import{difference as e,isSome as a}from"../../core/arrayUtils.js";import r from"../../core/Error.js";import{updateOrigins as t}from"../../core/accessorSupport/originUtils.js";import o from"../FeatureLayer.js";import{save as s,getLayerJSON as l,setCommonItemProperties as n,saveAs as i,getPortalItem as u,addItem as c,ensureLayerConfig as p,ensureItemConfig as m,createErrorMessage as f}from"./utils.js";import{parse as y}from"../support/arcgisLayerUrl.js";import{fetchFeatureService as d}from"../support/fetchService.js";import{isLayerWithFeatureLayerSource as h}from"../support/layerUtils.js";import{createForItemWrite as w}from"../../portal/support/jsonContext.js";import{getWGS84ExtentForItem as v,removeTypeKeyword as S,TypeKeyword as I,toggleTypeKeword as b,addTypeKeyword as T}from"../../portal/support/portalItemUtils.js";const P="Feature Service",$="feature-layer-utils",E=`${$}-save`,A=`${$}-save-as`,L=`${$}-saveall`,N=`${$}-saveall-as`;function x(e){return{isValid:h(e)&&("feature"!==e.type||!e.dynamicDataSource),errorMessage:"Feature layer should be a layer or table in a map or feature service"}}function j(e){const a=[],r=[];for(const{layer:t,layerJSON:o}of e)t.isTable?r.push(o):a.push(o);return{layers:a,tables:r}}function U(e){return j([e])}async function g(e,a){return/\/\d+\/?$/.test(e.url)?U(a[0]):O(a,e)}async function O(e,a){if(!a)return e.reverse(),j(e);const{layer:{url:r,customParameters:t,apiKey:o}}=e[0];let s=await a.fetchData("json");null!=s?.layers&&null!=s?.tables||(s=await J(s,{url:r??"",customParameters:t,apiKey:o},e.map((e=>e.layer.layerId))));for(const l of e)D(l.layer,l.layerJSON,s);return s}async function J(e,a,r){e||={},e.layers||=[],e.tables||=[];const{url:t,customParameters:o,apiKey:s}=a,{serviceJSON:l,layersJSON:n}=await d(t,{customParameters:o,apiKey:s}),i=M(e.layers,l.layers,r),u=M(e.tables,l.tables,r);e.layers=i.itemResources,e.tables=u.itemResources;const c=[...i.added,...u.added],p=n?[...n.layers,...n.tables]:[];return await R(e,c,t,p),e}function M(a,r,t){const o=e(a,r,((e,a)=>e.id===a.id));a=a.filter((e=>!o.removed.some((a=>a.id===e.id))));const s=o.added.map((({id:e})=>({id:e})));return s.forEach((({id:e})=>{a.push({id:e})})),{itemResources:a,added:s.filter((({id:e})=>!t.includes(e)))}}async function R(e,a,r,t){const s=a.map((({id:e})=>new o({url:r,layerId:e,sourceJSON:t.find((({id:a})=>a===e))})));await Promise.allSettled(s.map((e=>e.load()))),s.forEach((a=>{const{layerId:r,loaded:t,defaultPopupTemplate:o}=a;if(!t||null==o)return;D(a,{id:r,popupInfo:o.toJSON()},e)}))}function D(e,a,r){e.isTable?F(r.tables,a):F(r.layers,a)}function F(e,a){const r=e.findIndex((({id:e})=>e===a.id));-1===r?e.push(a):e[r]=a}function K(e,a){if(!e.length)throw new r(`${a}:missing-parameters`,"'layers' array should contain at least one feature layer")}function Y(e,a){const t=e.map((e=>e.portalItem.id));if(new Set(t).size>1)throw new r(`${a}:invalid-parameters`,"All layers in the 'layers' array should be loaded from the same portal item")}function _(e,a){const t=e.map((e=>e.layerId));if(new Set(t).size!==t.length)throw new r(`${a}:invalid-parameters`,"'layers' array should contain only one instance each of layer or table in a feature service")}async function z(e){K(e,L),await Promise.all(e.map((e=>e.load())));for(const a of e)p(a,L,x),m({layer:a,itemType:P,errorNamePrefix:L});Y(e,L),_(e,L)}async function B(e,a){const{url:r,layerId:t,title:o,fullExtent:s,isTable:l}=e,n=y(r);a.url="FeatureServer"===n?.serverType?r:`${r}/${t}`,a.title||=o,a.extent=null,l||null==s||(a.extent=await v(s)),S(a,I.METADATA),S(a,I.MULTI_LAYER),T(a,I.SINGLE_LAYER),l&&T(a,I.TABLE)}function G(e,a){for(const l of e){const t=l.parsedUrl.path,o=y(t),s=o?.url.path;if(!s)throw new r(`${a}:invalid-parameters`,f(l,`has unsupported url pattern: ${t}`),{layer:l});const n=o?.serverType;if("FeatureServer"!==n&&"MapServer"!==n)throw new r(`${a}:invalid-parameters`,f(l,`has unsupported server type: ${n}`),{layer:l});if("MapServer"===n&&e.length>1)throw new r(`${a}:invalid-parameters`,"Only one layer or table in a map service can be saved")}const t=y(e[0].parsedUrl.path),o=t?.url.path,s=e.every((e=>{const a=y(e.parsedUrl.path);return a?.url.path===o}));if(!s)throw new r(`${a}:invalid-parameters`,"'layers' array should only contain layers or tables that belong to the same feature service")}async function C(e){K(e,N),await Promise.all(e.map((e=>e.load())));for(const a of e)p(a,N,x);G(e,N),_(e,N)}async function V(e,r){let t=0,o=0;for(const{isTable:a}of r)a?o++:t++;const s=r[0].parsedUrl.path,l=y(s);if(e.url="FeatureServer"===l?.serverType?l.url.path:s,e.title||=l.title,e.extent=null,t>0){const t=r.map((e=>e.fullExtent)).filter(a).reduce(((e,a)=>e.clone().union(a)));t&&(e.extent=await v(t))}S(e,I.METADATA),b(e,I.MULTI_LAYER,r.length>1),b(e,I.SINGLE_LAYER,1===r.length),b(e,I.TABLE,o>0&&0===t),n(e)}async function k(e,a){return s({layer:e,itemType:P,validateLayer:x,createItemData:(e,a)=>g(a,[e]),errorNamePrefix:E},a)}async function q(e,a){await z(e);const r=e[0].portalItem,o=w(r),s=await Promise.all(e.map((e=>l(e,o,a)))),i=await g(r,e.map(((e,a)=>({layer:e,layerJSON:s[a]}))));return n(r),await r.update({data:i}),await Promise.all(e.slice(1).map((e=>e.portalItem.reload()))),t(o),r.clone()}async function H(e,a,r){return i({layer:e,itemType:P,validateLayer:x,createItemData:(e,a)=>Promise.resolve(U(e)),errorNamePrefix:A,newItem:a,setItemProperties:B},r)}async function Q(e,a,r){await C(e);const o=u({itemType:P,errorNamePrefix:N,newItem:a}),s=w(o),n=await Promise.all(e.map((e=>l(e,s,r)))),i=await O(e.map(((e,a)=>({layer:e,layerJSON:n[a]}))));await V(o,e),await c(o,i,r);for(const t of e)t.portalItem=o.clone();return t(s),o}export{k as save,q as saveAll,Q as saveAllAs,H as saveAs};
